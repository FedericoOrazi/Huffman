package tesina;
import tesina.MaxHeap;
import tesina.MaxHeap.HuffmanNode;
import java.util.Scanner; 


class Huffman { 

    public static void printCode(HuffmanNode root, String s) 
    { 
        // base case; if the left and right are null 
        // then its a leaf node and we print 
        // the code is generated by traversing the tree. 
        if (root.left == null && root.right == null && Character.isLetter(root.getValue())) { 
            // c is the character in the node 
            System.out.println(root.value + ":" + s); 
            return; 
        } 
        // if we go to left then add "0" to the code. 
        // if we go to the right add"1" to the code. 
        // recursive calls for left and 
        // right sub-tree of the generated tree. 
        printCode(root.left, s + "0"); 
        printCode(root.right, s + "1"); 
    } 
  
    // main function 
    public static void main(String[] args) 
    { 
  
        Scanner s = new Scanner(System.in); 
  
		// number of characters.
        int n = 6; 
        char[] charArray = {'a','b','c','d','e','f'}; 
        int[] charfreq = {45,13,12,16,9,5};
  
        // creating a priority queue q. 
        // makes a min-priority queue(min-heap). 
        MaxHeap M = new MaxHeap(n); 
  
        for (int i = 0; i < n; i++) { 
 
            HuffmanNode hn = new HuffmanNode(charfreq[i],charArray[i]); // creating a Huffman node object and add it to the priority queue. 
            
            hn.left = null; 
            hn.right = null; 
            
            M.insert(hn); // add function adds the huffman node to the queue. 
        } 
        // create a root node 
        HuffmanNode root = null; 
  
        // Here we will extract the two minimum value 
        // from the heap each time until 
        // its size reduces to 1, extract until 
        // all the nodes are extracted. 
        while (M.size > 1) { 
  
            // first min extract. 
            HuffmanNode x = M.extractMin(); 
            M.returnMax(); 
  
            // second min extract. 
            HuffmanNode y = M.extractMin(); 
            M.returnMax(); 
  
            // new node f which is equal 
            HuffmanNode f = new HuffmanNode(x.freq+y.freq,'-'); 
  
            // to the sum of the frequency of the two nodes assigning values to the f node. 
           // f.freq = x.freq + y.freq; 
           // f.c = '-'; 
  
            // first extracted node as left child. 
            f.left = x; 
  
            // second extracted node as the right child. 
            f.right = y; 
  
            // marking the f node as the root node. 
            root = f; 
  
            // add this node to the priority-queue. 
            M.insert(f); 
        } 
        // print the codes by traversing the tree 
        	printCode(root,""); 
    }

}
// This code is contributed by Kunwar Desh Deepak Singh 